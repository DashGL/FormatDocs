---
title: Player Model
description: A description of the mesh format used for the player character
---

import MermaidDiagram from '@components/MermaidDiagram.astro';

There is a separate model of MegaMan depending on the equipment.
The options for this are if a helmet is equipped or not, and if the shoes are jet, cleat, asbestos, or hover.
What this means is that most of the information in the model is duplicated, with the exception of the helmet and shoes.

| File | Helmet | Shoes |
| ---- | ------ | ---- |
| PL00P000.BIN | YES | Normal |
| PL00P001.BIN | YES | Jet Shoes |
| PL00P002.BIN | YES | Cleat Shoes |
| PL00P003.BIN | YES | Asbestos Shoes |
| PL00P004.BIN | YES | Hydo Shoes |
| PL00P005.BIN | YES | Hover Shoes |
| PL00P010.BIN | NO | Normal |
| PL00P011.BIN | NO | Jet Shoes |
| PL00P012.BIN | NO | Cleat Shoes | `
| PL00P013.BIN | NO | Asbestos Shoes |
| PL00P014.BIN | NO | Hydo Shoes |
| PL00P015.BIN | NO | Hover Shoes |

## Body Parts

Even through there are variations with all of the models, the offsets for the body parts are the same.
The mesh information stored in each `.BIN` files starts at `0x30` and is `0x2b40` in size.
These offsets are with respect to the start of the model file which is `0x30`.

For the purpose of this document, we will use the term "model" to refer to the enter file,
"mesh" refers to a single body part. And "strip" will refer to the list of commands that make up the mesh.

| Body Part| Offset| Number of Strips |
| --------| ----- | ---------------- |
| Bones| 0x00| 16 |
| Body| 0x80 | 6 |
| Head| 0xb60 | 3 |
| Feet| 0x1800 | 2 |
| Right Arm| 0x1dd0 | 3 |
| Buster| 0x2220 | 3 |
| Left Arm| 0x26f0 | 3 |

### Strip Format

Each strip is a list of vertices and indices used to draw the mesh.
Indices are described in either triangles or quads, and both reference the same vertex list.
For the same number of vertices, there are shading vertex colors that describe the local shadows for each face.

```c
typedef struct {
    utin8_t triCount;
    utin8_t quadCount;
    utin8_t vertexCount;
    uint8_t nop;
    uint32_t triOffset;
    uint32_t quadOffset;
    uint32_t vertexOffset;
    utin32_t activeVertexColors;
    utin32_t referenceVertexColors;
} StripHeader;
```

| 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x08 | 0x0c | 0x10 | 0x14 |
| --------| ----- | ---------------- | ----- | ---- | ----- | ---- | ----- | --- |
| Tri Count | Quad Count  | Vertex Count | NOP | Tri Ofs | Quad Ofs | Vertex Ofs | Tri Shadow Ofs | Quad Shadow Ofs |

### Vertex Format

Each vertex is encoded in a 32-bit word (`uint32_t`) which is split into different bit segments for the X, Y, and Z coordinates, as well as scale data:

- **32-bit word format:**
  - **X-axis**: The lowest 10 bits (bits 0–9).
  - **Y-axis**: The next 10 bits (bits 10–19).
  - **Z-axis**: The following 10 bits (bits 20–29).
  - **Scale**: The highest 2 bits (bits 30–31), which encode scaling information.

#### Scale Encoding

The two highest bits (30–31) represent scale data, which determines how much to scale the X, Y, and Z coordinates:
- `0b00`: 1x scale (no scaling).
- `0b01`: 2x scale.
- `0b10`: 4x scale.
- `0b11`: 0.5x scale.

#### Coordinate Representation

Each axis (X, Y, Z) is represented as a signed 10-bit integer:
- **Sign Bit**: The most significant bit (MSB) of each axis segment indicates the sign (negative if set).
- **Magnitude**: The remaining 9 bits represent the magnitude of the value.

#### PSX Coordinate System

The PSX coordinate system uses a convention where **-Y is up**. To align with this, the vertices are rotated by 180 degrees along the X-axis. Additionally, the PSX does not support floating-point values, so we scale down the vertices to bring them closer to real-world units, like meters.

#### Code Example

The following C code demonstrates how to decode the vertex data from a 32-bit word:

```c
#include <stdint.h>
#include <math.h>
#include <stdio.h>

#define SCALE 0.00125

// Function to read a vertex from a 32-bit encoded integer
void readVertex(uint32_t dword, float* x, float* y, float* z) {
    const uint32_t VERTEX_MASK = 0b1111111111;
    const uint32_t VERTEX_MSB = 0b1000000000;
    const uint32_t VERTEX_LOW = 0b0111111111;

    // Extract X, Y, Z using bit shifts and masks
    int32_t xBytes = (dword >> 0x00) & VERTEX_MASK;
    int32_t yBytes = (dword >> 0x0a) & VERTEX_MASK;
    int32_t zBytes = (dword >> 0x14) & VERTEX_MASK;

    // Apply sign to X, Y, Z
    int32_t xSign = (xBytes & VERTEX_MSB) ? -1 : 1;
    int32_t xValue = (xBytes & VERTEX_LOW);

    int32_t ySign = (yBytes & VERTEX_MSB) ? -1 : 1;
    int32_t yValue = (yBytes & VERTEX_LOW);

    int32_t zSign = (zBytes & VERTEX_MSB) ? -1 : 1;
    int32_t zValue = (zBytes & VERTEX_LOW);

    // Extract scale from the top 2 bits (30 and 31)
    uint32_t scaleBits = (dword >> 30) & 0b11;
    float scale = 1.0;
    switch (scaleBits) {
        case 0b00:
            scale = 1.0;
            break;
        case 0b01:
            scale = 2.0;
            break;
        case 0b10:
            scale = 4.0;
            break;
        case 0b11:
            scale = 0.5;
            break;
    }

    // Combine high and low parts for each axis
    *x = (xSign * xValue) * scale;
    *y = (ySign * yValue) * scale;
    *z = (zSign * zValue) * scale;

    // Apply final scaling to make units closer to meters
    *x *= SCALE;
    *y *= SCALE;
    *z *= SCALE;

    // Rotate by 180 degrees across the X-axis to match PSX format (-Y is up)
    *y = -*y; // Flip Y
}
```

### Face Format

Issue: https://github.com/kion-dgl/Miku-Legends-2/issues/12
